diff -ruN MetaMorpho.sol MetaMorpho.sol
--- MetaMorpho.sol
+++ MetaMorpho.sol
@@ -19,7 +19,6 @@
 import {UtilsLib} from "../lib/morpho-blue/src/libraries/UtilsLib.sol";
 import {SafeCast} from "../lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol";
 import {SharesMathLib} from "../lib/morpho-blue/src/libraries/SharesMathLib.sol";
-import {MorphoLib} from "../lib/morpho-blue/src/libraries/periphery/MorphoLib.sol";
 import {MarketParamsLib} from "../lib/morpho-blue/src/libraries/MarketParamsLib.sol";
 import {IERC20Metadata} from "../lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol";
 import {MorphoBalancesLib} from "../lib/morpho-blue/src/libraries/periphery/MorphoBalancesLib.sol";
@@ -45,9 +44,7 @@
     using UtilsLib for uint256;
     using SafeCast for uint256;
     using SafeERC20 for IERC20;
-    using MorphoLib for IMorpho;
     using SharesMathLib for uint256;
-    using MorphoBalancesLib for IMorpho;
     using MarketParamsLib for MarketParams;
     using PendingLib for MarketConfig;
     using PendingLib for PendingUint192;
@@ -273,7 +270,7 @@
     function submitCap(MarketParams memory marketParams, uint256 newSupplyCap) external onlyCuratorRole {
         Id id = marketParams.id();
         if (marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
-        if (MORPHO.lastUpdate(id) == 0) revert ErrorsLib.MarketNotCreated();
+        if (MORPHO.market(id).lastUpdate == 0) revert ErrorsLib.MarketNotCreated();
         if (pendingCap[id].validAt != 0) revert ErrorsLib.AlreadyPending();
         if (config[id].removableAt != 0) revert ErrorsLib.PendingRemoval();
         uint256 supplyCap = config[id].cap;
@@ -344,8 +341,7 @@
 
                 if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);
                 if (pendingCap[id].validAt != 0) revert ErrorsLib.PendingCap(id);
-
-                if (MORPHO.supplyShares(id, address(this)) != 0) {
+                if (IMorpho(MORPHO).position(id, address(this)).supplyShares != 0) {
                     if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);
 
                     if (block.timestamp < config[id].removableAt) {
@@ -585,7 +581,11 @@
     /// @inheritdoc IERC4626
     function totalAssets() public view override returns (uint256 assets) {
         for (uint256 i; i < withdrawQueue.length; ++i) {
-            assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
+            uint256 supplyShares =
+                IMorpho(MORPHO).position(_marketParams(withdrawQueue[i]).id(), address(this)).supplyShares;
+            (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) =
+                MorphoBalancesLib.expectedMarketBalances(MORPHO, _marketParams(withdrawQueue[i]));
+            assets += supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares);
         }
     }
 
@@ -619,8 +619,9 @@
             uint256 supplyCap = config[id].cap;
             if (supplyCap == 0) continue;
 
-            uint256 supplyShares = MORPHO.supplyShares(id, address(this));
-            (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = MORPHO.expectedMarketBalances(_marketParams(id));
+            uint256 supplyShares = IMorpho(MORPHO).position(id, address(this)).supplyShares;
+            (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) =
+                MorphoBalancesLib.expectedMarketBalances(MORPHO, _marketParams(id));
             // `supplyAssets` needs to be rounded up for `totalSuppliable` to be rounded down.
             uint256 supplyAssets = supplyShares.toAssetsUp(totalSupplyAssets, totalSupplyShares);
 
@@ -709,7 +710,7 @@
         MORPHO.accrueInterest(marketParams);
 
         market = MORPHO.market(id);
-        shares = MORPHO.supplyShares(id, address(this));
+        shares = IMorpho(MORPHO).position(id, address(this)).supplyShares;
         assets = shares.toAssetsDown(market.totalSupplyAssets, market.totalSupplyShares);
     }
 
@@ -751,7 +752,9 @@
                 marketConfig.enabled = true;
 
                 // Take into account assets of the new market without applying a fee.
-                _updateLastTotalAssets(lastTotalAssets + MORPHO.expectedSupplyAssets(marketParams, address(this)));
+                _updateLastTotalAssets(
+                    lastTotalAssets + MorphoBalancesLib.expectedSupplyAssets(MORPHO, marketParams, address(this))
+                );
 
                 emit EventsLib.SetWithdrawQueue(msg.sender, withdrawQueue);
             }
@@ -781,7 +784,7 @@
             MORPHO.accrueInterest(marketParams);
 
             Market memory market = MORPHO.market(id);
-            uint256 supplyShares = MORPHO.supplyShares(id, address(this));
+            uint256 supplyShares = IMorpho(MORPHO).position(id, address(this)).supplyShares;
             // `supplyAssets` needs to be rounded up for `toSupply` to be rounded down.
             uint256 supplyAssets = supplyShares.toAssetsUp(market.totalSupplyAssets, market.totalSupplyShares);
 
@@ -831,9 +834,9 @@
             Id id = withdrawQueue[i];
             MarketParams memory marketParams = _marketParams(id);
 
-            uint256 supplyShares = MORPHO.supplyShares(id, address(this));
+            uint256 supplyShares = IMorpho(MORPHO).position(id, address(this)).supplyShares;
             (uint256 totalSupplyAssets, uint256 totalSupplyShares, uint256 totalBorrowAssets,) =
-                MORPHO.expectedMarketBalances(marketParams);
+                MorphoBalancesLib.expectedMarketBalances(MORPHO, marketParams);
 
             // The vault withdrawing from Morpho cannot fail because:
             // 1. oracle.price() is never called (the vault doesn't borrow)
