diff -ruN MetaMorpho.sol MetaMorpho.sol
--- MetaMorpho.sol
+++ MetaMorpho.sol
@@ -19,7 +19,6 @@
 import {UtilsLib} from "../lib/morpho-blue/src/libraries/UtilsLib.sol";
 import {SafeCast} from "../lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol";
 import {SharesMathLib} from "../lib/morpho-blue/src/libraries/SharesMathLib.sol";
-import {MorphoLib} from "../lib/morpho-blue/src/libraries/periphery/MorphoLib.sol";
 import {MarketParamsLib} from "../lib/morpho-blue/src/libraries/MarketParamsLib.sol";
 import {IERC20Metadata} from "../lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol";
 import {MorphoBalancesLib} from "../lib/morpho-blue/src/libraries/periphery/MorphoBalancesLib.sol";
@@ -45,7 +44,6 @@
     using UtilsLib for uint256;
     using SafeCast for uint256;
     using SafeERC20 for IERC20;
-    using MorphoLib for IMorpho;
     using SharesMathLib for uint256;
     using MorphoBalancesLib for IMorpho;
     using MarketParamsLib for MarketParams;
@@ -273,7 +271,7 @@
     function submitCap(MarketParams memory marketParams, uint256 newSupplyCap) external onlyCuratorRole {
         Id id = marketParams.id();
         if (marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
-        if (MORPHO.lastUpdate(id) == 0) revert ErrorsLib.MarketNotCreated();
+        if (MORPHO.market(id).lastUpdate == 0) revert ErrorsLib.MarketNotCreated();
         if (pendingCap[id].validAt != 0) revert ErrorsLib.AlreadyPending();
         if (config[id].removableAt != 0) revert ErrorsLib.PendingRemoval();
         uint256 supplyCap = config[id].cap;
@@ -344,8 +342,7 @@
 
                 if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);
                 if (pendingCap[id].validAt != 0) revert ErrorsLib.PendingCap(id);
-
-                if (MORPHO.supplyShares(id, address(this)) != 0) {
+                if (IMorpho(MORPHO).position(id, address(this)).supplyShares != 0) {
                     if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);
 
                     if (block.timestamp < config[id].removableAt) {
@@ -585,7 +582,7 @@
     /// @inheritdoc IERC4626
     function totalAssets() public view override returns (uint256 assets) {
         for (uint256 i; i < withdrawQueue.length; ++i) {
-            assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
+            assets += expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
         }
     }
 
@@ -619,7 +616,7 @@
             uint256 supplyCap = config[id].cap;
             if (supplyCap == 0) continue;
 
-            uint256 supplyShares = MORPHO.supplyShares(id, address(this));
+            uint256 supplyShares = IMorpho(MORPHO).position(id, address(this)).supplyShares;
             (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = MORPHO.expectedMarketBalances(_marketParams(id));
             // `supplyAssets` needs to be rounded up for `totalSuppliable` to be rounded down.
             uint256 supplyAssets = supplyShares.toAssetsUp(totalSupplyAssets, totalSupplyShares);
@@ -709,7 +706,7 @@
         MORPHO.accrueInterest(marketParams);
 
         market = MORPHO.market(id);
-        shares = MORPHO.supplyShares(id, address(this));
+        shares = IMorpho(MORPHO).position(id, address(this)).supplyShares;
         assets = shares.toAssetsDown(market.totalSupplyAssets, market.totalSupplyShares);
     }
 
@@ -751,7 +748,7 @@
                 marketConfig.enabled = true;
 
                 // Take into account assets of the new market without applying a fee.
-                _updateLastTotalAssets(lastTotalAssets + MORPHO.expectedSupplyAssets(marketParams, address(this)));
+                _updateLastTotalAssets(lastTotalAssets + expectedSupplyAssets(marketParams, address(this)));
 
                 emit EventsLib.SetWithdrawQueue(msg.sender, withdrawQueue);
             }
@@ -781,7 +778,7 @@
             MORPHO.accrueInterest(marketParams);
 
             Market memory market = MORPHO.market(id);
-            uint256 supplyShares = MORPHO.supplyShares(id, address(this));
+            uint256 supplyShares = IMorpho(MORPHO).position(id, address(this)).supplyShares;
             // `supplyAssets` needs to be rounded up for `toSupply` to be rounded down.
             uint256 supplyAssets = supplyShares.toAssetsUp(market.totalSupplyAssets, market.totalSupplyShares);
 
@@ -831,7 +828,7 @@
             Id id = withdrawQueue[i];
             MarketParams memory marketParams = _marketParams(id);
 
-            uint256 supplyShares = MORPHO.supplyShares(id, address(this));
+            uint256 supplyShares = IMorpho(MORPHO).position(id, address(this)).supplyShares;
             (uint256 totalSupplyAssets, uint256 totalSupplyShares, uint256 totalBorrowAssets,) =
                 MORPHO.expectedMarketBalances(marketParams);
 
@@ -905,4 +902,11 @@
                 _convertToSharesWithTotals(feeAssets, totalSupply(), newTotalAssets - feeAssets, Math.Rounding.Floor);
         }
     }
+
+    function expectedSupplyAssets(MarketParams memory marketParams, address user) internal view returns (uint256) {
+        Id id = marketParams.id();
+        uint256 supplyShares = IMorpho(MORPHO).position(id, user).supplyShares;
+        (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = MORPHO.expectedMarketBalances(marketParams);
+        return supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares);
+    }
 }
